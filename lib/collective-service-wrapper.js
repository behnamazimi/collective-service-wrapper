!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("collectiveServiceWrapper",[],t):"object"==typeof exports?exports.collectiveServiceWrapper=t():e.collectiveServiceWrapper=t()}(this,(function(){return function(e){var t={};function s(i){if(t[i])return t[i].exports;var o=t[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=e,s.c=t,s.d=function(e,t,i){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)s.d(i,o,function(t){return e[t]}.bind(null,o));return i},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=0)}([function(e,t,s){"use strict";s.r(t),s.d(t,"HOOKS",(function(){return o})),s.d(t,"ServiceWrapper",(function(){return r})),s.d(t,"ClientHandler",(function(){return n}));var i=(()=>{let e;return{getInstance:()=>(e||(e={_debugMode:!1,log(...e){this._debugMode&&console.log(...e)},set debugMode(e){this._debugMode=e},count:0,_requests:{},generateNewID(){return this.count++,this.count+"__"+Math.random().toString(32).substr(2).substr(6)},onTurn(e,t){this._requests[e]={...this._requests[e],listener:t,status:"pending"}},fire(e,...t){this._requests[e]&&"function"==typeof this._requests[e].listener&&(this.log(`* FIRED: ${e} [type: ${this._requests[e].status}]`),this._requests[e].status="fired",this._requests[e].listener.apply(this,t))},add(e={}){const t=this.generateNewID();return this._requests[t]=e,this.log("+ ADDED: "+t),t},checkIdleStatus(e,t=!1){return new Promise(s=>{if(this.onTurn(e,s),t)return this._requests[e].status="parallel",void this.fire(e);const i=Object.keys(this._requests);i.length&&i[0]!==e||this.fire(e)})},removeRequest(e){delete this._requests[e],this.log("- REMOVED: "+e);const t=Object.keys(this._requests),s=this._requests[t[0]];s&&"pending"===s.status&&this.fire(t[0])}}),e)}})();const o={BEFORE_RESOLVE:"before.resolve",BEFORE_REJECT:"before.reject",BEFORE_FIRE:"before.fire",AFTER_SUCCESS:"after.success",AFTER_FAIL:"after.fail",UPDATE_REQUEST_CONFIG:"update.request-config"},r={__proto__:{HOOKS:o,_hooks:{},client:null,queue:null,setClient(e){this.client=e},addToQueue(){if(this.queue)return this.queue.add()},checkQueueStatus(...e){if(this.queue)return this.queue.checkIdleStatus(...e)},removeQueueRequest(e){if(this.queue)return this.queue.removeRequest(e)},setHook(e,t){this._hooks[e]=t},execHook(e,...t){if(this._hooks[e])return this._hooks[e].apply(null,t)},init(e={}){if(!e||"[object Object]"!==e.toString())throw new Error("Invalid options passed.");return e.client&&this.setClient(e.client),e.queue?(this.queue=i.getInstance(),this.queue.debugMode=!!e.queueLogs):this.queue=null,this}}};r.setHook(o.BEFORE_RESOLVE,e=>e),r.setHook(o.BEFORE_RESOLVE,e=>e),r.setHook(o.UPDATE_REQUEST_CONFIG,e=>e);class n{constructor(...e){if(this._client=r.client,!this._client||"function"!=typeof this._client)throw new Error("HTTP client must be a function");this._reqConfig=e,this._id=r.addToQueue(),this._customHooks={}}setClient(e){if(!e||"function"!=typeof e)throw new Error("Invalid client passed. Client must be a function");return this._client=e,this}setHook(e,t){return e&&"function"==typeof t&&(this._customHooks[e]=t),this}execHook(e,...t){return this._customHooks[e]&&"function"==typeof this._customHooks[e]?this._customHooks[e].apply(null,t):r.execHook(e,...t)}fire(e={}){return this._fireOptions=e,this._fireOptions&&"object"==typeof this._fireOptions||(this._fireOptions={parallel:!0}),this._reqConfig=[this.execHook(o.UPDATE_REQUEST_CONFIG,...this._reqConfig)],new Promise(async(e,t)=>{try{await r.checkQueueStatus(this._id,this._fireOptions.parallel),this.execHook(o.BEFORE_FIRE,this._fireOptions);const t=await this._client(...this._reqConfig);200===t.status&&(this.execHook(o.AFTER_SUCCESS,t,this._fireOptions),e(this.execHook(o.BEFORE_RESOLVE,t,this._fireOptions)))}catch(e){console.log(e),this.execHook(o.AFTER_FAIL,e,this._fireOptions),t(this.execHook(o.BEFORE_REJECT,e,this._fireOptions))}finally{r.removeQueueRequest(this._id)}})}}}])}));